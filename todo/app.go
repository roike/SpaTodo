package todo

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"

	"golang.org/x/net/context"

	"google.golang.org/appengine"
	"google.golang.org/appengine/datastore"
	"google.golang.org/appengine/user"

	. "github.com/roike/helper/wrapper"
)

const (
	// datastore entity kind to identify users.
	userKind = "User"
	// datastore entity kind for List
	listKind = "List"
	// datastore entity kind for Task
	taskKind = "Task"
)

// List represents a lists of tasks.
type List struct {
	// Autogenerated id, not stored in the datastore.
	ID string `datastore:"-"`

	Name    string `datastore:",noindex"`
	Creator string
	Date    time.Time
}

// Task represents an task in a todo list.
type Task struct {
	// Autogenerated id, not stored in the datastore.
	ID int64 `datastore:"-"`

	//Text describing the task
	Text string `datastore:",noindex"`
	Done bool   // Completion state of the task.
	Time int64  // UnixTime used to sort the tasks chronologically.
}

func init() {
	// Register all the handlers.
	r := mux.NewRouter().PathPrefix("/api/").Subrouter()

	// List management
	r.Handle("/list/type/{type}", AuthReq(getAllLists)).Methods("GET")
	r.Handle("/list", AuthReq(createList)).Methods("POST")
	r.Handle("/list/{list}", AuthReq(getList)).Methods("GET")
	r.Handle("/list/{list}", AuthReq(deleteList)).Methods("DELETE")

	// Task management.
	r.Handle("/task/{list}", AppHandler(getTasks)).Methods("GET")
	r.Handle("/task/{list}", AuthReq(createTask)).Methods("POST")
	r.Handle("/task/{list}/{task}", AuthReq(updateTask)).Methods("PATCH")

	http.Handle("/api/", r)
}

// type == all-->グループリスト others -->user only list
func getAllLists(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)
	u := user.Current(c)
	query := datastore.NewQuery(listKind)

	// If the user is logged in fetch only their lists.
	if group := mux.Vars(r)["type"]; group != "all" {
		userKey := datastore.NewKey(c, userKind, u.Email, 0, nil)
		query = query.Ancestor(userKey)
	}
	query = query.Order("-Date")
	lists := make([]*List, 0)
	keys, err := query.GetAll(c, &lists)
	if err != nil {
		return fmt.Errorf("fetch all lists: %v", err)
	}
	// Update the encoded keys and encode the lists.
	for i, k := range keys {
		lists[i].ID = k.Encode()
	}

	return json.NewEncoder(w).Encode(lists)

}

// createList creates a new list. It reads a JSON encoded list from the request
// body and checks that the user is logged in.
func createList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode a list from the request body.
	list := List{}
	err := json.NewDecoder(r.Body).Decode(&list)
	if err != nil {
		return AppErrorf(http.StatusBadRequest, "decode list: %v", err)
	}
	list.Creator = user.Current(c).Email
	list.Date = time.Now()

	// Put the List in the datastore.
	userKey := datastore.NewKey(c, userKind, list.Creator, 0, nil)
	key := datastore.NewIncompleteKey(c, listKind, userKey)
	key, err = datastore.Put(c, key, &list)
	if err != nil {
		return fmt.Errorf("create list: %v", err)
	}

	// Update the encoded key and encode the list.
	list.ID = key.Encode()

	return json.NewEncoder(w).Encode(list)

}

// getList fetches the list with the id given in the url and encodes it in
// JSON format into the http response.
func getList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list id from the URL.
	id := mux.Vars(r)["list"]

	// Decode the obtained id into a datastore key.
	key, err := datastore.DecodeKey(id)
	if err != nil {
		return AppErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch the list from the datastore.
	list := new(List)
	err = datastore.Get(c, key, list)
	if err == datastore.ErrNoSuchEntity {
		return AppErrorf(http.StatusNotFound, "list not found")
	}
	if err != nil {
		return fmt.Errorf("fetch list: %v", err)
	}

	// Set the ID field with the id from the request url and encode the list.
	list.ID = id
	return json.NewEncoder(w).Encode(list)
}

// decode decodes a key from the given list id and finds the email of the creator
// of the list, which corresponds to the StringID of the ancestor key.
func decode(listID string) (list *datastore.Key, email string, err error) {
	// Decode the obtained id into a datastore key.
	list, err = datastore.DecodeKey(listID)
	if err != nil {
		return nil, "", AppErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Check that the logged in user is the creator of the list.
	user := list.Parent()
	if user == nil {
		return nil, "", AppErrorf(http.StatusBadRequest, "list missing parent")
	}
	return list, user.StringID(), nil
}

// deleteList deletes the list with the id given in the url if the user is
// logged in and is the creator of the list.
func deleteList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	key, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return AppErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	// Delete all tasks in the list and the list itself in a transaction.
	err = datastore.RunInTransaction(c, func(c context.Context) error {
		// Find all the tasks in the list.
		taskKeys, err := datastore.NewQuery(taskKind).
			Ancestor(key).KeysOnly().GetAll(c, nil)
		if err != nil {
			return fmt.Errorf("get all tasks in list: %v", err)
		}

		// Delete all the tasks in the list.
		err = datastore.DeleteMulti(c, taskKeys)
		if err != nil {
			return fmt.Errorf("delete all tasks in list: %v", err)
		}

		// Delete the list itself.
		return datastore.Delete(c, key)
	}, nil)

	if err != nil {
		return fmt.Errorf("fetch list: %v", err)
	}
	list := List{}
	list.ID = key.Encode()
	return json.NewEncoder(w).Encode(list)
}

// getTasks fetches all the tasks in the list with the id given in the url and
// encodes them in JSON format into the http response.
func getTasks(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list key from the url and decode it.
	listKey, err := datastore.DecodeKey(mux.Vars(r)["list"])
	if err != nil {
		return AppErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch all the tasks from datastore.
	tasks := make([]*Task, 0)
	keys, err := datastore.NewQuery(taskKind).Ancestor(listKey).GetAll(c, &tasks)
	if err != nil {
		return fmt.Errorf("fetch tasks: %v", err)
	}

	// Update the encoded keys and encode the tasks.
	for i, key := range keys {
		tasks[i].ID = key.IntID()
	}
	return json.NewEncoder(w).Encode(tasks)
}

// createTask parses a task from the request body in JSON format and adds it to
// the list with the id given in the url. Finally it encodes the created task
// with the generated id into the http response.
func createTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return AppErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	// Decode the task from the request body.
	task := Task{}
	err = json.NewDecoder(r.Body).Decode(&task)
	if err != nil {
		return AppErrorf(http.StatusBadRequest, "decode task: %v", err)
	}

	// Set the creation time in the task and put it in the datastore.
	task.Time = time.Now().Unix()
	key := datastore.NewIncompleteKey(c, taskKind, listKey)
	key, err = datastore.Put(c, key, &task)
	if err != nil {
		return fmt.Errorf("add task: %v", err)
	}

	// Add the encoded key before encoding the task to JSON.
	task.ID = key.IntID()
	return json.NewEncoder(w).Encode(task)
}

// updateTask parses a task from the request body in JSON format and updates
// the task identified by the url in the datastore.
func updateTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return AppErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	taskID, err := strconv.ParseInt(mux.Vars(r)["task"], 10, 64)
	if err != nil {
		return AppErrorf(http.StatusBadRequest, "invalid task id")
	}

	task := Task{}
	if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
		return AppErrorf(http.StatusBadRequest, "decode task: %v", err)
	}

	// Check if the Task exists already and fail if it doesn't.
	oldTask := Task{}
	key := datastore.NewKey(c, taskKind, "", taskID, listKey)
	err = datastore.Get(c, key, &oldTask)
	if err == datastore.ErrNoSuchEntity {
		return AppErrorf(http.StatusNotFound, "task not found")
	}
	if err != nil {
		return fmt.Errorf("fetch task: %v", err)
	}

	// We update only the Done field, ignoring anything else.
	oldTask.Done = task.Done

	key, err = datastore.Put(c, key, &oldTask)
	if err != nil {
		return fmt.Errorf("patch task: %v", err)
	}
	oldTask.ID = key.IntID()
	return json.NewEncoder(w).Encode(oldTask)
}
